desc:QuickDelay

slider1:delayms=250<1,1000>Delay Time (ms)
slider2:sync=0<0,16,1{Off,1/16,1/8,1/4,1/2,1/1,1/16t,1/8t,1/4t,1/2t,1/1t,1/16.,1/8.,1/4.,1/2.,1/1.}>Tempo sync
slider3:feedback=0<0,1>Feedback
slider4:mode=1<0,1,1{Normal,Ping Pong}>Mode
slider5:spread=0<-100,100,1>Spread

import qd.delay.jsfx-inc

@init
// 20 second stereo delay line
d0.delay(srate * 10);
d1.delay(srate * 10);

@slider
lfactor = spread > 0 ? 1 - spread / 100 : 1;
rfactor = spread < 0 ? 1 + spread / 100 : 1;

@block
while (midirecv(offset, msg1, note, vel)) (
  event = msg1 & 0xF0;
  event == 0xB0 && note == 123 ? ( // All notes off
    memset(d0.buf, 0, d0.size);
    memset(d1.buf, 0, d1.size);
  );
);

sync > 0 ? (
  sync == 1 ? delayms = 60000 / 4 / tempo:        // 1/16
  sync == 2 ? delayms = 60000 / 2 / tempo:        // 1/8
  sync == 3 ? delayms = 60000 / tempo:            // 1/4
  sync == 4 ? delayms = 60000 * 2 / tempo:        // 1/2
  sync == 5 ? delayms = 60000 * 4 / tempo:        // 1/1
  sync == 6 ? delayms = 60000 / 6 / tempo:        // 1/16t
  sync == 7 ? delayms = 60000 / 3 / tempo:        // 1/8t
  sync == 8 ? delayms = 60000 / 3 * 2 / tempo:    // 1/4t
  sync == 9 ? delayms = 60000 / 3 * 4 / tempo:    // 1/2t
  sync == 10 ? delayms = 60000 / 3 * 8 / tempo:   // 1/1t
  sync == 11 ? delayms = 60000 / 4 * 1.5 / tempo: // 1/16.
  sync == 12 ? delayms = 60000 / 2 * 1.5 / tempo: // 1/8.
  sync == 13 ? delayms = 60000 * 1.5 / tempo:     // 1/4.
  sync == 14 ? delayms = 60000 * 2 * 1.5 / tempo: // 1/2.
  sync == 15 ? delayms = 60000 * 4 * 1.5 / tempo: // 1/1.
  1;
);

delayms > 10000 ? delayms = 10000;
samps = delayms * 0.001 * srate; // delay time in samples

// clear delay on all notes off

@sample
// read with cubic interpolation
val0 = d0.delay_read3(samps);
val1 = d1.delay_read3(samps);

// apply filters on val0 and val1

// write values in delay lines
mode == 0 ? (
  d0.delay_write(spl0 + val0 * feedback);
  d1.delay_write(spl1 + val1 * feedback);
) : mode == 1 ? (
  d0.delay_write(spl0 * lfactor + val1 * feedback);
  d1.delay_write(spl1 * rfactor + val0 * feedback);
);

// sum and output
spl0 = spl0 + val0;
spl1 = spl1 + val1;
